{"version":3,"sources":["../src/index.ts","../src/config.ts","../src/client.ts","../src/storage-service.ts","../src/image-processor.ts","../src/upload-utils.ts","../src/render-storage.ts"],"sourcesContent":["export * from './types';\nexport * from './config';\nexport * from './client';\nexport * from './storage-service';\nexport * from './image-processor';\nexport * from './upload-utils';\nexport * from './render-storage';\n\n// Default exports for convenience\nexport { StorageService as default } from './storage-service';","import type { StorageConfig } from './types';\n\nexport function getStorageConfig(): StorageConfig {\n  const projectId = process.env.GCS_PROJECT_ID;\n  const rendersBucket = process.env.GCS_RENDERS_BUCKET;\n  const assetsBucket = process.env.GCS_ASSETS_BUCKET;\n\n  if (!projectId || !rendersBucket || !assetsBucket) {\n    throw new Error(\n      'Missing required Google Cloud Storage environment variables: GCS_PROJECT_ID, GCS_RENDERS_BUCKET, GCS_ASSETS_BUCKET'\n    );\n  }\n\n  return {\n    projectId,\n    rendersBucket,\n    assetsBucket,\n    keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS,\n    cdnUrl: process.env.GCS_CDN_URL,\n  };\n}","import { Storage } from '@google-cloud/storage';\nimport { getStorageConfig } from './config';\n\nlet storageClient: Storage | null = null;\n\nexport function getStorageClient(): Storage {\n  if (!storageClient) {\n    const config = getStorageConfig();\n    \n    storageClient = new Storage({\n      projectId: config.projectId,\n      keyFilename: config.keyFilename,\n    });\n  }\n  \n  return storageClient;\n}\n\nexport function getBucket(bucketType: 'renders' | 'assets') {\n  const client = getStorageClient();\n  const config = getStorageConfig();\n  \n  const bucketName = bucketType === 'renders' \n    ? config.rendersBucket \n    : config.assetsBucket;\n    \n  return client.bucket(bucketName);\n}","import { lookup } from 'mime-types';\nimport { getBucket } from './client';\nimport { getStorageConfig } from './config';\nimport { ImageProcessor } from './image-processor';\nimport type { \n  UploadOptions, \n  UploadResult, \n  SignedUrlOptions, \n  StorageBucket,\n  ImageOptimizationOptions \n} from './types';\n\nexport class StorageService {\n  private config = getStorageConfig();\n\n  async uploadFile(options: UploadOptions): Promise<UploadResult> {\n    const {\n      bucket: bucketType,\n      fileName,\n      buffer,\n      contentType,\n      metadata = {},\n      makePublic = false,\n    } = options;\n\n    const bucket = getBucket(bucketType);\n    const file = bucket.file(fileName);\n\n    // Determine content type\n    const finalContentType = contentType || lookup(fileName) || 'application/octet-stream';\n\n    // Upload file\n    await file.save(buffer, {\n      metadata: {\n        contentType: finalContentType,\n        metadata,\n      },\n      resumable: false,\n    });\n\n    // Make public if requested\n    if (makePublic) {\n      await file.makePublic();\n    }\n\n    const bucketName = bucketType === 'renders' \n      ? this.config.rendersBucket \n      : this.config.assetsBucket;\n\n    const publicUrl = this.getPublicUrl(bucketName, fileName);\n\n    return {\n      fileName,\n      bucket: bucketName,\n      publicUrl,\n      size: buffer.length,\n      contentType: finalContentType,\n    };\n  }\n\n  async uploadImage(\n    bucketType: StorageBucket,\n    fileName: string,\n    buffer: Buffer,\n    optimizationOptions?: ImageOptimizationOptions\n  ): Promise<{ original: UploadResult; thumbnail?: UploadResult }> {\n    // Optimize original image if options provided\n    let finalBuffer = buffer;\n    let contentType = 'image/jpeg';\n\n    if (optimizationOptions) {\n      const optimized = await ImageProcessor.optimizeImage(buffer, optimizationOptions);\n      finalBuffer = optimized.buffer;\n      contentType = optimized.contentType;\n    }\n\n    // Upload original/optimized image\n    const original = await this.uploadFile({\n      bucket: bucketType,\n      fileName,\n      buffer: finalBuffer,\n      contentType,\n      makePublic: true,\n    });\n\n    // Create and upload thumbnail if not already a thumbnail\n    let thumbnail: UploadResult | undefined;\n    if (!optimizationOptions?.thumbnail) {\n      const thumbnailBuffer = await ImageProcessor.createThumbnail(buffer);\n      const thumbnailFileName = this.getThumbnailFileName(fileName);\n      \n      thumbnail = await this.uploadFile({\n        bucket: bucketType,\n        fileName: thumbnailFileName,\n        buffer: thumbnailBuffer,\n        contentType: 'image/webp',\n        makePublic: true,\n      });\n    }\n\n    return { original, thumbnail };\n  }\n\n  async generateSignedUrl(options: SignedUrlOptions): Promise<string> {\n    const {\n      bucket: bucketType,\n      fileName,\n      action,\n      expires = new Date(Date.now() + 15 * 60 * 1000), // 15 minutes default\n      contentType,\n    } = options;\n\n    const bucket = getBucket(bucketType);\n    const file = bucket.file(fileName);\n\n    const [url] = await file.getSignedUrl({\n      version: 'v4',\n      action,\n      expires,\n      contentType,\n    });\n\n    return url;\n  }\n\n  async generateUploadUrl(\n    bucketType: StorageBucket,\n    fileName: string,\n    contentType: string,\n    expires?: Date\n  ): Promise<string> {\n    return this.generateSignedUrl({\n      bucket: bucketType,\n      fileName,\n      action: 'write',\n      contentType,\n      expires,\n    });\n  }\n\n  async generateDownloadUrl(\n    bucketType: StorageBucket,\n    fileName: string,\n    expires?: Date\n  ): Promise<string> {\n    return this.generateSignedUrl({\n      bucket: bucketType,\n      fileName,\n      action: 'read',\n      expires,\n    });\n  }\n\n  async deleteFile(bucketType: StorageBucket, fileName: string): Promise<void> {\n    const bucket = getBucket(bucketType);\n    const file = bucket.file(fileName);\n    \n    await file.delete();\n  }\n\n  async fileExists(bucketType: StorageBucket, fileName: string): Promise<boolean> {\n    const bucket = getBucket(bucketType);\n    const file = bucket.file(fileName);\n    \n    const [exists] = await file.exists();\n    return exists;\n  }\n\n  async getFileMetadata(bucketType: StorageBucket, fileName: string) {\n    const bucket = getBucket(bucketType);\n    const file = bucket.file(fileName);\n    \n    const [metadata] = await file.getMetadata();\n    return metadata;\n  }\n\n  async copyFile(\n    sourceBucket: StorageBucket,\n    sourceFileName: string,\n    destBucket: StorageBucket,\n    destFileName: string\n  ): Promise<void> {\n    const sourceBucketObj = getBucket(sourceBucket);\n    const destBucketObj = getBucket(destBucket);\n    \n    const sourceFile = sourceBucketObj.file(sourceFileName);\n    const destFile = destBucketObj.file(destFileName);\n    \n    await sourceFile.copy(destFile);\n  }\n\n  getPublicUrl(bucketName: string, fileName: string): string {\n    if (this.config.cdnUrl) {\n      return `${this.config.cdnUrl}/${fileName}`;\n    }\n    return `https://storage.googleapis.com/${bucketName}/${fileName}`;\n  }\n\n  private getThumbnailFileName(originalFileName: string): string {\n    const lastDotIndex = originalFileName.lastIndexOf('.');\n    if (lastDotIndex === -1) {\n      return `${originalFileName}_thumb.webp`;\n    }\n    \n    const name = originalFileName.substring(0, lastDotIndex);\n    return `${name}_thumb.webp`;\n  }\n\n  // Utility methods for common file operations\n  async uploadRenderResult(\n    renderId: string,\n    imageBuffer: Buffer,\n    metadata?: Record<string, string>\n  ): Promise<{ original: UploadResult; thumbnail: UploadResult }> {\n    const fileName = `renders/${renderId}.webp`;\n    \n    const result = await this.uploadImage('renders', fileName, imageBuffer, {\n      format: 'webp',\n      quality: 85,\n    });\n\n    // Add metadata to both files\n    if (metadata && result.thumbnail) {\n      const bucket = getBucket('renders');\n      const originalFile = bucket.file(fileName);\n      const thumbnailFile = bucket.file(this.getThumbnailFileName(fileName));\n\n      await Promise.all([\n        originalFile.setMetadata({ metadata }),\n        thumbnailFile.setMetadata({ metadata }),\n      ]);\n    }\n\n    return result as { original: UploadResult; thumbnail: UploadResult };\n  }\n\n  async uploadAsset(\n    assetId: string,\n    imageBuffer: Buffer,\n    metadata?: Record<string, string>\n  ): Promise<{ original: UploadResult; thumbnail: UploadResult }> {\n    const fileName = `assets/${assetId}.webp`;\n    \n    const result = await this.uploadImage('assets', fileName, imageBuffer, {\n      format: 'webp',\n      quality: 90,\n    });\n\n    if (metadata && result.thumbnail) {\n      const bucket = getBucket('assets');\n      const originalFile = bucket.file(fileName);\n      const thumbnailFile = bucket.file(this.getThumbnailFileName(fileName));\n\n      await Promise.all([\n        originalFile.setMetadata({ metadata }),\n        thumbnailFile.setMetadata({ metadata }),\n      ]);\n    }\n\n    return result as { original: UploadResult; thumbnail: UploadResult };\n  }\n}","import sharp from 'sharp';\nimport type { ImageOptimizationOptions } from './types';\n\nexport class ImageProcessor {\n  static async optimizeImage(\n    buffer: Buffer,\n    options: ImageOptimizationOptions = {}\n  ): Promise<{ buffer: Buffer; contentType: string; size: number }> {\n    const {\n      width,\n      height,\n      quality = 80,\n      format = 'webp',\n      thumbnail = false,\n    } = options;\n\n    let processor = sharp(buffer);\n\n    // Resize if dimensions specified\n    if (width || height) {\n      processor = processor.resize(width, height, {\n        fit: 'inside',\n        withoutEnlargement: true,\n      });\n    }\n\n    // Create thumbnail if requested\n    if (thumbnail) {\n      processor = processor.resize(300, 300, {\n        fit: 'cover',\n        position: 'center',\n      });\n    }\n\n    // Convert format and apply quality\n    switch (format) {\n      case 'webp':\n        processor = processor.webp({ quality });\n        break;\n      case 'jpeg':\n        processor = processor.jpeg({ quality });\n        break;\n      case 'png':\n        processor = processor.png({ quality });\n        break;\n    }\n\n    const optimizedBuffer = await processor.toBuffer();\n    \n    return {\n      buffer: optimizedBuffer,\n      contentType: `image/${format}`,\n      size: optimizedBuffer.length,\n    };\n  }\n\n  static async createThumbnail(buffer: Buffer): Promise<Buffer> {\n    return sharp(buffer)\n      .resize(300, 300, {\n        fit: 'cover',\n        position: 'center',\n      })\n      .webp({ quality: 70 })\n      .toBuffer();\n  }\n\n  static async getImageMetadata(buffer: Buffer) {\n    const metadata = await sharp(buffer).metadata();\n    return {\n      width: metadata.width,\n      height: metadata.height,\n      format: metadata.format,\n      size: metadata.size,\n      hasAlpha: metadata.hasAlpha,\n    };\n  }\n}","import { StorageService } from './storage-service';\nimport type { StorageBucket } from './types';\n\nexport class UploadUtils {\n  private static storageService = new StorageService();\n\n  /**\n   * Generate a direct upload URL for client-side uploads\n   */\n  static async generateDirectUploadUrl(\n    bucketType: StorageBucket,\n    fileName: string,\n    contentType: string,\n    expiresInMinutes = 15\n  ): Promise<{\n    uploadUrl: string;\n    fileName: string;\n    publicUrl: string;\n    expiresAt: Date;\n  }> {\n    const expiresAt = new Date(Date.now() + expiresInMinutes * 60 * 1000);\n    \n    const uploadUrl = await this.storageService.generateUploadUrl(\n      bucketType,\n      fileName,\n      contentType,\n      expiresAt\n    );\n\n    const bucketName = bucketType === 'renders' \n      ? process.env.GCS_RENDERS_BUCKET!\n      : process.env.GCS_ASSETS_BUCKET!;\n\n    const publicUrl = this.storageService.getPublicUrl(bucketName, fileName);\n\n    return {\n      uploadUrl,\n      fileName,\n      publicUrl,\n      expiresAt,\n    };\n  }\n\n  /**\n   * Generate unique file name with timestamp and random suffix\n   */\n  static generateFileName(prefix: string, extension: string): string {\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 8);\n    return `${prefix}/${timestamp}-${random}.${extension}`;\n  }\n\n  /**\n   * Generate file name for render result\n   */\n  static generateRenderFileName(renderId: string, format = 'webp'): string {\n    return `renders/${renderId}.${format}`;\n  }\n\n  /**\n   * Generate file name for asset\n   */\n  static generateAssetFileName(assetId: string, format = 'webp'): string {\n    return `assets/${assetId}.${format}`;\n  }\n\n  /**\n   * Generate file name for user upload\n   */\n  static generateUserUploadFileName(\n    userId: string,\n    originalFileName: string\n  ): string {\n    const extension = originalFileName.split('.').pop() || 'jpg';\n    const timestamp = Date.now();\n    const random = Math.random().toString(36).substring(2, 8);\n    return `uploads/${userId}/${timestamp}-${random}.${extension}`;\n  }\n\n  /**\n   * Validate file type for uploads\n   */\n  static validateImageFile(contentType: string, maxSizeMB = 10): {\n    valid: boolean;\n    error?: string;\n  } {\n    const allowedTypes = [\n      'image/jpeg',\n      'image/jpg', \n      'image/png',\n      'image/webp',\n      'image/gif',\n    ];\n\n    if (!allowedTypes.includes(contentType.toLowerCase())) {\n      return {\n        valid: false,\n        error: `Invalid file type. Allowed: ${allowedTypes.join(', ')}`,\n      };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Get CORS configuration for direct uploads\n   */\n  static getCorsConfig() {\n    return {\n      origin: [\n        process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000',\n        'https://terrashaper.pro',\n        'https://*.terrashaper.pro',\n      ],\n      methods: ['GET', 'PUT', 'POST', 'OPTIONS'],\n      allowedHeaders: [\n        'Content-Type',\n        'Content-Length',\n        'x-goog-content-length-range',\n        'x-goog-resumable',\n      ],\n      maxAgeSeconds: 3600,\n    };\n  }\n\n  /**\n   * Create presigned POST policy for direct browser uploads\n   */\n  static async generatePresignedPost(\n    bucketType: StorageBucket,\n    fileName: string,\n    contentType: string,\n    maxSizeBytes = 10 * 1024 * 1024 // 10MB default\n  ): Promise<{\n    url: string;\n    fields: Record<string, string>;\n  }> {\n    // For Google Cloud Storage, we'll use signed URLs instead of presigned POST\n    // This is a simplified version - you might want to implement proper presigned POST\n    const uploadUrl = await this.storageService.generateUploadUrl(\n      bucketType,\n      fileName,\n      contentType\n    );\n\n    return {\n      url: uploadUrl,\n      fields: {\n        'Content-Type': contentType,\n      },\n    };\n  }\n}","import { StorageService } from './storage-service';\nimport { ImageProcessor } from './image-processor';\nimport type { UploadResult } from './types';\n\nexport class RenderStorageService extends StorageService {\n  /**\n   * Store a completed render result with optimized images and thumbnails\n   */\n  async storeRenderResult(\n    renderId: string,\n    imageBuffer: Buffer,\n    metadata: {\n      userId: string;\n      projectId: string;\n      sceneId: string;\n      provider: string;\n      prompt: string;\n      settings: Record<string, any>;\n      processingTime?: number;\n      originalSize?: number;\n    }\n  ): Promise<{\n    original: UploadResult;\n    thumbnail: UploadResult;\n    webp: UploadResult;\n    metadata: any;\n  }> {\n    const fileName = `renders/${renderId}`;\n    \n    // Get image metadata\n    const imageMetadata = await ImageProcessor.getImageMetadata(imageBuffer);\n    \n    // Create optimized WebP version\n    const webpOptimized = await ImageProcessor.optimizeImage(imageBuffer, {\n      format: 'webp',\n      quality: 85,\n      width: Math.min(imageMetadata.width || 2048, 2048),\n      height: Math.min(imageMetadata.height || 2048, 2048),\n    });\n    \n    // Create thumbnail\n    const thumbnailBuffer = await ImageProcessor.createThumbnail(imageBuffer);\n    \n    // Upload all versions\n    const [original, webp, thumbnail] = await Promise.all([\n      // Original (high quality)\n      this.uploadFile({\n        bucket: 'renders',\n        fileName: `${fileName}_original.${imageMetadata.format || 'jpg'}`,\n        buffer: imageBuffer,\n        contentType: `image/${imageMetadata.format || 'jpeg'}`,\n        makePublic: true,\n        metadata: {\n          renderId,\n          type: 'original',\n          userId: metadata.userId,\n          projectId: metadata.projectId,\n          provider: metadata.provider,\n        },\n      }),\n      \n      // Optimized WebP (primary display)\n      this.uploadFile({\n        bucket: 'renders',\n        fileName: `${fileName}.webp`,\n        buffer: webpOptimized.buffer,\n        contentType: webpOptimized.contentType,\n        makePublic: true,\n        metadata: {\n          renderId,\n          type: 'optimized',\n          userId: metadata.userId,\n          projectId: metadata.projectId,\n          provider: metadata.provider,\n        },\n      }),\n      \n      // Thumbnail\n      this.uploadFile({\n        bucket: 'renders',\n        fileName: `${fileName}_thumb.webp`,\n        buffer: thumbnailBuffer,\n        contentType: 'image/webp',\n        makePublic: true,\n        metadata: {\n          renderId,\n          type: 'thumbnail',\n          userId: metadata.userId,\n          projectId: metadata.projectId,\n          provider: metadata.provider,\n        },\n      }),\n    ]);\n\n    // Store metadata file\n    const metadataContent = {\n      renderId,\n      ...metadata,\n      images: {\n        original: {\n          url: original.publicUrl,\n          size: original.size,\n          contentType: original.contentType,\n          width: imageMetadata.width,\n          height: imageMetadata.height,\n        },\n        webp: {\n          url: webp.publicUrl,\n          size: webp.size,\n          contentType: webp.contentType,\n        },\n        thumbnail: {\n          url: thumbnail.publicUrl,\n          size: thumbnail.size,\n          contentType: thumbnail.contentType,\n        },\n      },\n      createdAt: new Date().toISOString(),\n    };\n\n    await this.uploadFile({\n      bucket: 'renders',\n      fileName: `${fileName}_metadata.json`,\n      buffer: Buffer.from(JSON.stringify(metadataContent, null, 2)),\n      contentType: 'application/json',\n      makePublic: false,\n      metadata: {\n        renderId,\n        type: 'metadata',\n      },\n    });\n\n    return {\n      original,\n      webp,\n      thumbnail,\n      metadata: metadataContent,\n    };\n  }\n\n  /**\n   * Get render result URLs\n   */\n  async getRenderUrls(renderId: string): Promise<{\n    original?: string;\n    webp?: string;\n    thumbnail?: string;\n    metadata?: any;\n  } | null> {\n    try {\n      const fileName = `renders/${renderId}`;\n      \n      // Check if main WebP exists\n      const webpExists = await this.fileExists('renders', `${fileName}.webp`);\n      if (!webpExists) {\n        return null;\n      }\n\n      // Get public URLs\n      const bucketName = process.env.GCS_RENDERS_BUCKET!;\n      \n      const urls = {\n        webp: this.getPublicUrl(bucketName, `${fileName}.webp`),\n        thumbnail: this.getPublicUrl(bucketName, `${fileName}_thumb.webp`),\n      };\n\n      // Check for original and metadata\n      const [originalExists, metadataExists] = await Promise.all([\n        this.checkOriginalFile(renderId),\n        this.fileExists('renders', `${fileName}_metadata.json`),\n      ]);\n\n      if (originalExists.exists) {\n        (urls as any).original = this.getPublicUrl(bucketName, originalExists.fileName);\n      }\n\n      let metadata = null;\n      if (metadataExists) {\n        try {\n          // Generate signed URL to read metadata (since it's private)\n          const metadataUrl = await this.generateDownloadUrl(\n            'renders',\n            `${fileName}_metadata.json`,\n            new Date(Date.now() + 5 * 60 * 1000) // 5 minutes\n          );\n          \n          const response = await fetch(metadataUrl);\n          if (response.ok) {\n            metadata = await response.json();\n          }\n        } catch (error) {\n          console.warn('Failed to fetch render metadata:', error);\n        }\n      }\n\n      return { ...urls, metadata };\n    } catch (error) {\n      console.error('Failed to get render URLs:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Delete all files associated with a render\n   */\n  async deleteRender(renderId: string): Promise<void> {\n    const fileName = `renders/${renderId}`;\n    \n    // List all possible files for this render\n    const possibleFiles = [\n      `${fileName}.webp`,\n      `${fileName}_thumb.webp`,\n      `${fileName}_metadata.json`,\n    ];\n\n    // Check for original files (unknown format)\n    const originalFile = await this.checkOriginalFile(renderId);\n    if (originalFile.exists) {\n      possibleFiles.push(originalFile.fileName);\n    }\n\n    // Delete all existing files\n    const deletePromises = possibleFiles.map(async (file) => {\n      try {\n        const exists = await this.fileExists('renders', file);\n        if (exists) {\n          await this.deleteFile('renders', file);\n        }\n      } catch (error) {\n        console.warn(`Failed to delete file ${file}:`, error);\n      }\n    });\n\n    await Promise.all(deletePromises);\n  }\n\n  /**\n   * Check for original file with unknown extension\n   */\n  private async checkOriginalFile(renderId: string): Promise<{\n    exists: boolean;\n    fileName: string;\n  }> {\n    const fileName = `renders/${renderId}`;\n    const possibleExtensions = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'tiff'];\n    \n    for (const ext of possibleExtensions) {\n      const testFileName = `${fileName}_original.${ext}`;\n      const exists = await this.fileExists('renders', testFileName);\n      if (exists) {\n        return { exists: true, fileName: testFileName };\n      }\n    }\n    \n    return { exists: false, fileName: '' };\n  }\n\n  /**\n   * Generate download URLs for render results\n   */\n  async generateRenderDownloadUrls(\n    renderId: string,\n    expiresInHours = 24\n  ): Promise<{\n    original?: string;\n    webp?: string;\n    thumbnail?: string;\n  }> {\n    const fileName = `renders/${renderId}`;\n    const expires = new Date(Date.now() + expiresInHours * 60 * 60 * 1000);\n    \n    const urls: any = {};\n\n    // Generate signed URLs for private access\n    try {\n      const webpExists = await this.fileExists('renders', `${fileName}.webp`);\n      if (webpExists) {\n        urls.webp = await this.generateDownloadUrl('renders', `${fileName}.webp`, expires);\n      }\n\n      const thumbExists = await this.fileExists('renders', `${fileName}_thumb.webp`);\n      if (thumbExists) {\n        urls.thumbnail = await this.generateDownloadUrl('renders', `${fileName}_thumb.webp`, expires);\n      }\n\n      const originalFile = await this.checkOriginalFile(renderId);\n      if (originalFile.exists) {\n        urls.original = await this.generateDownloadUrl('renders', originalFile.fileName, expires);\n      }\n    } catch (error) {\n      console.error('Failed to generate download URLs:', error);\n    }\n\n    return urls;\n  }\n}"],"mappings":"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","names":["sharp"]}